using Microsoft.VisualStudio.TestTools.UnitTesting;
using FinancialRisk.Api.Services;
using FinancialRisk.Api.Models;
using FinancialRisk.Api.Controllers;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;

namespace FinancialRisk.Tests
{
    [TestClass]
    public class PortfolioOptimizationTests
    {
        private IPortfolioOptimizationService _optimizationService;
        private PortfolioOptimizationController _controller;

        [TestInitialize]
        public void Setup()
        {
            _optimizationService = new PortfolioOptimizationService();
            _controller = new PortfolioOptimizationController(_optimizationService);
        }

        [TestMethod]
        public async Task MarkowitzOptimization_WithKnownDataset_ReturnsOptimalWeights()
        {
            // Arrange - Known dataset with expected optimal weights
            var expectedReturns = new List<double> { 0.08, 0.12, 0.06 }; // 8%, 12%, 6% expected returns
            var covarianceMatrix = new List<List<double>>
            {
                new List<double> { 0.04, 0.01, 0.02 }, // 4% variance, 1% cov with asset 2, 2% cov with asset 3
                new List<double> { 0.01, 0.09, 0.03 }, // 1% cov with asset 1, 9% variance, 3% cov with asset 3
                new List<double> { 0.02, 0.03, 0.06 }  // 2% cov with asset 1, 3% cov with asset 2, 6% variance
            };

            var request = new PortfolioOptimizationRequest
            {
                Method = "mean_variance",
                Assets = new List<AssetOptimizationData>
                {
                    new AssetOptimizationData { Symbol = "Asset1", ExpectedReturn = expectedReturns[0] },
                    new AssetOptimizationData { Symbol = "Asset2", ExpectedReturn = expectedReturns[1] },
                    new AssetOptimizationData { Symbol = "Asset3", ExpectedReturn = expectedReturns[2] }
                },
                CovarianceMatrix = covarianceMatrix,
                RiskAversion = 1.0,
                Constraints = new Dictionary<string, object>
                {
                    ["max_weight"] = 0.5,
                    ["min_weight"] = 0.0
                }
            };

            // Act
            var result = await _controller.OptimizePortfolio(request);

            // Assert
            Assert.IsTrue(result.IsSuccess);
            Assert.IsNotNull(result.Data);
            Assert.IsNotNull(result.Data.OptimalWeights);
            Assert.AreEqual(3, result.Data.OptimalWeights.Count);

            // Check that weights sum to 1 (or close to 1 due to floating point precision)
            var totalWeight = result.Data.OptimalWeights.Sum(w => w.Weight);
            Assert.AreEqual(1.0, totalWeight, 0.001, "Weights should sum to 1");

            // Check that all weights are non-negative
            foreach (var weight in result.Data.OptimalWeights)
            {
                Assert.IsTrue(weight.Weight >= 0, "All weights should be non-negative");
                Assert.IsTrue(weight.Weight <= 0.5, "All weights should respect max constraint");
            }

            // Verify that the highest return asset gets significant weight
            var maxReturnAsset = result.Data.OptimalWeights
                .OrderByDescending(w => w.Weight)
                .First();
            Assert.IsTrue(maxReturnAsset.Weight > 0.3, "Highest return asset should get significant weight");
        }

        [TestMethod]
        public async Task SharpeRatio_WithKnownParameters_ReturnsExpectedValue()
        {
            // Arrange - Known parameters for Sharpe ratio calculation
            var portfolioReturn = 0.12; // 12% annual return
            var riskFreeRate = 0.03;   // 3% risk-free rate
            var portfolioVolatility = 0.15; // 15% annual volatility
            var expectedSharpeRatio = (portfolioReturn - riskFreeRate) / portfolioVolatility; // Should be 0.6

            var expectedReturns = new List<double> { 0.08, 0.12, 0.06 };
            var covarianceMatrix = new List<List<double>>
            {
                new List<double> { 0.04, 0.01, 0.02 },
                new List<double> { 0.01, 0.09, 0.03 },
                new List<double> { 0.02, 0.03, 0.06 }
            };

            var request = new PortfolioOptimizationRequest
            {
                Method = "mean_variance",
                Assets = new List<AssetOptimizationData>
                {
                    new AssetOptimizationData { Symbol = "Asset1", ExpectedReturn = expectedReturns[0] },
                    new AssetOptimizationData { Symbol = "Asset2", ExpectedReturn = expectedReturns[1] },
                    new AssetOptimizationData { Symbol = "Asset3", ExpectedReturn = expectedReturns[2] }
                },
                CovarianceMatrix = covarianceMatrix,
                RiskAversion = 1.0,
                RiskFreeRate = riskFreeRate
            };

            // Act
            var result = await _controller.OptimizePortfolio(request);

            // Assert
            Assert.IsTrue(result.IsSuccess);
            Assert.IsNotNull(result.Data);
            Assert.IsTrue(result.Data.SharpeRatio > 0, "Sharpe ratio should be positive");
            
            // The Sharpe ratio should be reasonable (between 0 and 2 for this dataset)
            Assert.IsTrue(result.Data.SharpeRatio < 2.0, "Sharpe ratio should be reasonable");
        }

        [TestMethod]
        public async Task EfficientFrontier_WithKnownDataset_ReturnsValidFrontier()
        {
            // Arrange
            var expectedReturns = new List<double> { 0.08, 0.12, 0.06 };
            var covarianceMatrix = new List<List<double>>
            {
                new List<double> { 0.04, 0.01, 0.02 },
                new List<double> { 0.01, 0.09, 0.03 },
                new List<double> { 0.02, 0.03, 0.06 }
            };

            var request = new EfficientFrontierRequest
            {
                Assets = new List<AssetOptimizationData>
                {
                    new AssetOptimizationData { Symbol = "Asset1", ExpectedReturn = expectedReturns[0] },
                    new AssetOptimizationData { Symbol = "Asset2", ExpectedReturn = expectedReturns[1] },
                    new AssetOptimizationData { Symbol = "Asset3", ExpectedReturn = expectedReturns[2] }
                },
                CovarianceMatrix = covarianceMatrix,
                NumPoints = 20
            };

            // Act
            var result = await _controller.CalculateEfficientFrontier(request);

            // Assert
            Assert.IsTrue(result.IsSuccess);
            Assert.IsNotNull(result.Data);
            Assert.IsNotNull(result.Data.FrontierPoints);
            Assert.IsTrue(result.Data.FrontierPoints.Count > 0, "Efficient frontier should have points");

            // Check that frontier points are ordered by risk (volatility)
            var frontierPoints = result.Data.FrontierPoints.OrderBy(p => p.ExpectedVolatility).ToList();
            for (int i = 1; i < frontierPoints.Count; i++)
            {
                Assert.IsTrue(frontierPoints[i].ExpectedVolatility >= frontierPoints[i-1].ExpectedVolatility,
                    "Frontier points should be ordered by increasing volatility");
            }

            // Check that each point has valid weights
            foreach (var point in result.Data.FrontierPoints)
            {
                Assert.IsNotNull(point.Weights);
                Assert.AreEqual(3, point.Weights.Count, "Each point should have weights for all assets");
                
                var totalWeight = point.Weights.Sum(w => w.Weight);
                Assert.AreEqual(1.0, totalWeight, 0.001, "Weights should sum to 1");
            }
        }

        [TestMethod]
        public async Task MinimumVariance_WithKnownDataset_ReturnsMinimumVariancePortfolio()
        {
            // Arrange
            var expectedReturns = new List<double> { 0.08, 0.12, 0.06 };
            var covarianceMatrix = new List<List<double>>
            {
                new List<double> { 0.04, 0.01, 0.02 },
                new List<double> { 0.01, 0.09, 0.03 },
                new List<double> { 0.02, 0.03, 0.06 }
            };

            var request = new PortfolioOptimizationRequest
            {
                Method = "minimum_variance",
                Assets = new List<AssetOptimizationData>
                {
                    new AssetOptimizationData { Symbol = "Asset1", ExpectedReturn = expectedReturns[0] },
                    new AssetOptimizationData { Symbol = "Asset2", ExpectedReturn = expectedReturns[1] },
                    new AssetOptimizationData { Symbol = "Asset3", ExpectedReturn = expectedReturns[2] }
                },
                CovarianceMatrix = covarianceMatrix
            };

            // Act
            var result = await _controller.OptimizePortfolio(request);

            // Assert
            Assert.IsTrue(result.IsSuccess);
            Assert.IsNotNull(result.Data);
            Assert.IsNotNull(result.Data.OptimalWeights);

            // Check that weights sum to 1
            var totalWeight = result.Data.OptimalWeights.Sum(w => w.Weight);
            Assert.AreEqual(1.0, totalWeight, 0.001, "Weights should sum to 1");

            // The minimum variance portfolio should have reasonable volatility
            Assert.IsTrue(result.Data.ExpectedVolatility > 0, "Volatility should be positive");
            Assert.IsTrue(result.Data.ExpectedVolatility < 0.5, "Volatility should be reasonable");
        }

        [TestMethod]
        public async Task RiskParity_WithKnownDataset_ReturnsEqualRiskContribution()
        {
            // Arrange
            var covarianceMatrix = new List<List<double>>
            {
                new List<double> { 0.04, 0.01, 0.02 },
                new List<double> { 0.01, 0.09, 0.03 },
                new List<double> { 0.02, 0.03, 0.06 }
            };

            var request = new PortfolioOptimizationRequest
            {
                Method = "risk_parity",
                Assets = new List<AssetOptimizationData>
                {
                    new AssetOptimizationData { Symbol = "Asset1", ExpectedReturn = 0.08 },
                    new AssetOptimizationData { Symbol = "Asset2", ExpectedReturn = 0.12 },
                    new AssetOptimizationData { Symbol = "Asset3", ExpectedReturn = 0.06 }
                },
                CovarianceMatrix = covarianceMatrix
            };

            // Act
            var result = await _controller.OptimizePortfolio(request);

            // Assert
            Assert.IsTrue(result.IsSuccess);
            Assert.IsNotNull(result.Data);
            Assert.IsNotNull(result.Data.OptimalWeights);

            // Check that weights sum to 1
            var totalWeight = result.Data.OptimalWeights.Sum(w => w.Weight);
            Assert.AreEqual(1.0, totalWeight, 0.001, "Weights should sum to 1");

            // Risk parity should have more balanced weights compared to mean-variance
            var maxWeight = result.Data.OptimalWeights.Max(w => w.Weight);
            var minWeight = result.Data.OptimalWeights.Min(w => w.Weight);
            var weightSpread = maxWeight - minWeight;
            
            // Risk parity should have more balanced weights (smaller spread)
            Assert.IsTrue(weightSpread < 0.8, "Risk parity should have more balanced weights");
        }

        [TestMethod]
        public async Task EqualWeight_WithKnownDataset_ReturnsEqualWeights()
        {
            // Arrange
            var request = new PortfolioOptimizationRequest
            {
                Method = "equal_weight",
                Assets = new List<AssetOptimizationData>
                {
                    new AssetOptimizationData { Symbol = "Asset1", ExpectedReturn = 0.08 },
                    new AssetOptimizationData { Symbol = "Asset2", ExpectedReturn = 0.12 },
                    new AssetOptimizationData { Symbol = "Asset3", ExpectedReturn = 0.06 }
                },
                CovarianceMatrix = new List<List<double>>
                {
                    new List<double> { 0.04, 0.01, 0.02 },
                    new List<double> { 0.01, 0.09, 0.03 },
                    new List<double> { 0.02, 0.03, 0.06 }
                }
            };

            // Act
            var result = await _controller.OptimizePortfolio(request);

            // Assert
            Assert.IsTrue(result.IsSuccess);
            Assert.IsNotNull(result.Data);
            Assert.IsNotNull(result.Data.OptimalWeights);

            // All weights should be equal (1/3 for 3 assets)
            var expectedWeight = 1.0 / 3.0;
            foreach (var weight in result.Data.OptimalWeights)
            {
                Assert.AreEqual(expectedWeight, weight.Weight, 0.001, "All weights should be equal");
            }
        }

        [TestMethod]
        public async Task BlackLitterman_WithKnownDataset_ReturnsValidWeights()
        {
            // Arrange
            var marketCapWeights = new List<double> { 0.4, 0.4, 0.2 }; // Market cap weights
            var views = new List<double> { 0.15, 0.05 }; // Views on first two assets

            var request = new BlackLittermanRequest
            {
                Assets = new List<AssetOptimizationData>
                {
                    new AssetOptimizationData { Symbol = "Asset1", ExpectedReturn = 0.08 },
                    new AssetOptimizationData { Symbol = "Asset2", ExpectedReturn = 0.12 },
                    new AssetOptimizationData { Symbol = "Asset3", ExpectedReturn = 0.06 }
                },
                CovarianceMatrix = new List<List<double>>
                {
                    new List<double> { 0.04, 0.01, 0.02 },
                    new List<double> { 0.01, 0.09, 0.03 },
                    new List<double> { 0.02, 0.03, 0.06 }
                },
                MarketCapWeights = marketCapWeights,
                Views = views,
                RiskAversion = 1.0
            };

            // Act
            var result = await _controller.PerformBlackLittermanOptimization(request);

            // Assert
            Assert.IsTrue(result.IsSuccess);
            Assert.IsNotNull(result.Data);
            Assert.IsNotNull(result.Data.OptimalWeights);

            // Check that weights sum to 1
            var totalWeight = result.Data.OptimalWeights.Sum(w => w.Weight);
            Assert.AreEqual(1.0, totalWeight, 0.001, "Weights should sum to 1");

            // All weights should be non-negative
            foreach (var weight in result.Data.OptimalWeights)
            {
                Assert.IsTrue(weight.Weight >= 0, "All weights should be non-negative");
            }
        }

        [TestMethod]
        public async Task Optimization_WithInvalidInput_ReturnsError()
        {
            // Arrange - Empty assets list
            var request = new PortfolioOptimizationRequest
            {
                Method = "mean_variance",
                Assets = new List<AssetOptimizationData>(), // Empty list
                CovarianceMatrix = new List<List<double>>()
            };

            // Act
            var result = await _controller.OptimizePortfolio(request);

            // Assert
            Assert.IsFalse(result.IsSuccess);
            Assert.IsNotNull(result.ErrorMessage);
        }

        [TestMethod]
        public async Task Optimization_WithMismatchedDimensions_ReturnsError()
        {
            // Arrange - Mismatched dimensions between assets and covariance matrix
            var request = new PortfolioOptimizationRequest
            {
                Method = "mean_variance",
                Assets = new List<AssetOptimizationData>
                {
                    new AssetOptimizationData { Symbol = "Asset1", ExpectedReturn = 0.08 },
                    new AssetOptimizationData { Symbol = "Asset2", ExpectedReturn = 0.12 }
                },
                CovarianceMatrix = new List<List<double>>
                {
                    new List<double> { 0.04, 0.01, 0.02 }, // 3x3 matrix for 2 assets
                    new List<double> { 0.01, 0.09, 0.03 },
                    new List<double> { 0.02, 0.03, 0.06 }
                }
            };

            // Act
            var result = await _controller.OptimizePortfolio(request);

            // Assert
            Assert.IsFalse(result.IsSuccess);
            Assert.IsNotNull(result.ErrorMessage);
        }

        [TestMethod]
        public async Task Optimization_WithNegativeReturns_HandlesCorrectly()
        {
            // Arrange - Assets with negative expected returns
            var request = new PortfolioOptimizationRequest
            {
                Method = "mean_variance",
                Assets = new List<AssetOptimizationData>
                {
                    new AssetOptimizationData { Symbol = "Asset1", ExpectedReturn = -0.05 },
                    new AssetOptimizationData { Symbol = "Asset2", ExpectedReturn = 0.10 },
                    new AssetOptimizationData { Symbol = "Asset3", ExpectedReturn = 0.03 }
                },
                CovarianceMatrix = new List<List<double>>
                {
                    new List<double> { 0.04, 0.01, 0.02 },
                    new List<double> { 0.01, 0.09, 0.03 },
                    new List<double> { 0.02, 0.03, 0.06 }
                }
            };

            // Act
            var result = await _controller.OptimizePortfolio(request);

            // Assert
            Assert.IsTrue(result.IsSuccess);
            Assert.IsNotNull(result.Data);
            Assert.IsNotNull(result.Data.OptimalWeights);

            // The asset with negative return should get minimal or zero weight
            var negativeReturnAsset = result.Data.OptimalWeights
                .FirstOrDefault(w => w.Symbol == "Asset1");
            Assert.IsNotNull(negativeReturnAsset);
            Assert.IsTrue(negativeReturnAsset.Weight <= 0.1, 
                "Asset with negative return should get minimal weight");
        }

        [TestMethod]
        public async Task Optimization_Performance_WithLargeDataset_CompletesInReasonableTime()
        {
            // Arrange - Large dataset to test performance
            var numAssets = 50;
            var assets = new List<AssetOptimizationData>();
            var covarianceMatrix = new List<List<double>>();

            var random = new Random(42);
            for (int i = 0; i < numAssets; i++)
            {
                assets.Add(new AssetOptimizationData
                {
                    Symbol = $"Asset{i + 1}",
                    ExpectedReturn = random.NextDouble() * 0.2 - 0.1 // Random returns between -10% and 10%
                });

                var row = new List<double>();
                for (int j = 0; j < numAssets; j++)
                {
                    if (i == j)
                        row.Add(0.04); // 4% variance
                    else
                        row.Add(0.01); // 1% covariance
                }
                covarianceMatrix.Add(row);
            }

            var request = new PortfolioOptimizationRequest
            {
                Method = "mean_variance",
                Assets = assets,
                CovarianceMatrix = covarianceMatrix
            };

            // Act
            var startTime = DateTime.Now;
            var result = await _controller.OptimizePortfolio(request);
            var executionTime = DateTime.Now - startTime;

            // Assert
            Assert.IsTrue(result.IsSuccess, "Optimization should succeed with large dataset");
            Assert.IsTrue(executionTime.TotalSeconds < 10, 
                "Optimization should complete within 10 seconds for 50 assets");
        }
    }
}